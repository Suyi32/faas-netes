// Copyright (c) Alex Ellis 2017. All rights reserved.
// Copyright 2020 OpenFaaS Author(s)
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

package k8s

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
	"bytes"
	"strconv"
	"log"

	corelister "k8s.io/client-go/listers/core/v1"
)

// watchdogPort for the OpenFaaS function watchdog
const watchdogPort = 8080
var lock sync.Mutex

type ScaleServiceRequest struct {
	ServiceName string `json:"serviceName"`
	Replicas    uint64 `json:"replicas"`
}

type FlaskRequest struct {
	X []float64
}

func containsIP(s []string, str string) bool {
	for _, v := range s {
		if v == str {
			return true
		}
	}
	return false
}

func GetConcurrency(endpoint string) map[string]float64 {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// curl
	resp, err := http.Get(fmt.Sprintf("http://%s:%d/_/context", endpoint, watchdogPort))
	if err != nil {
		panic(err.Error())
	}
	defer resp.Body.Close()


	var respJson map[string]float64
	err = json.NewDecoder(resp.Body).Decode(&respJson)
	if err != nil {
		panic(err)
	}
	// fmt.Println(resp.Body)
	// fmt.Println(respJson["InFlight"])

	return respJson  
}

func getValues(contextInfo map[string]float64, key string) float64 {
	val, ok := contextInfo[key]
	if ok {
		return val
	} else {
        fmt.Println(key, " NOT defined." )
    }
	return 0.0
}

func GetPred(fc_name string, contextInfo map[string]float64) int {
	// [ "CPU", "Memo", "Inflight", "gmm_co", "qv_co", "ts_co", "ca_co" ]

	// Inflight_val, _ := strconv.ParseFloat( getValues(contextInfo, "InFlight"), 64 )
	Inflight_val := getValues(contextInfo, "InFlight")
	if  Inflight_val == 0.0 {
		log.Println(fc_name, "No DT: 0", Inflight_val, getValues(contextInfo, "CPU"), getValues(contextInfo, "Memo"))
		return 0
	}

	CPU  :=  getValues(contextInfo, "CPU")
	Memo :=  getValues(contextInfo, "Memo")

	// flask_url := "http://10.43.5.119:8080"
	flask_url := os.Getenv("flask_url")
	urlPath := fmt.Sprintf("%s/%s/predict", flask_url, fc_name)
	flaskReq := FlaskRequest{
		X: []float64{ CPU, Memo, Inflight_val },
	}
	requestBody, err := json.Marshal(flaskReq)
	resp, err := http.Post(urlPath, "application/json", bytes.NewBuffer(requestBody))
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	
	var respJson map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&respJson)
	
	predRes, err := json.Marshal(respJson)
	if err != nil {
		fmt.Println("Json conversion error")
		panic(err)
	}
	log.Println("DT PRED: ", string(predRes))

	res, err := strconv.Atoi( fmt.Sprintf("%v", respJson["predictions"]) )
	if err != nil {
		fmt.Println("String to Int error")
		panic(err)
	}
	return res
}

func max(numbers map[string]int64, fc_name string) string {
	var maxNumber int64
	var maxIPAddr string = ""

	if len(numbers) == 0 {
		fmt.Println("[ERROR] No available endpoint address.")
		os.Exit(1)
	}

	maxNumber = 0

	for ipAddr, n := range numbers {
		respJson := GetConcurrency(ipAddr) 
		DT_pred  := GetPred(fc_name, respJson)
		// fmt.Println("DT pred", DT_pred) 
		if (respJson["MaxConn"] != respJson["InFlight"]) && n >= maxNumber && DT_pred == 0 {
			maxNumber = n
			maxIPAddr = ipAddr
		}
	}

	return maxIPAddr
}

func selectDT(IPs []string, fc_name string) string {
	var IPAddr string = ""

	for _, IP := range IPs {
		respJson := GetConcurrency(IP) 
		DT_pred  := GetPred(fc_name, respJson)
		log.Println("DT_pred: ", DT_pred, "Condition: ", DT_pred == 0, DT_pred == 1, "\n")
		if (respJson["MaxConn"] != respJson["InFlight"]) && DT_pred == 0 {
			return IP
		}
	}
	return IPAddr
}

func NewFunctionLookup(ns string, lister corelister.EndpointsLister) *FunctionLookup {
	var funcRouteMap2D map[string]map[string]int64
	funcRouteMap2D = make(map[string]map[string]int64)

	return &FunctionLookup{
		DefaultNamespace: ns,
		EndpointLister:   lister,
		Listers:          map[string]corelister.EndpointsNamespaceLister{},
		lock:             sync.RWMutex{},
		routeMap2D:       funcRouteMap2D,
	}
}

type FunctionLookup struct {
	DefaultNamespace string
	EndpointLister   corelister.EndpointsLister
	Listers          map[string]corelister.EndpointsNamespaceLister

	lock       sync.RWMutex
	routeMap2D map[string]map[string]int64
}

func (f *FunctionLookup) GetLister(ns string) corelister.EndpointsNamespaceLister {
	f.lock.RLock()
	defer f.lock.RUnlock()
	return f.Listers[ns]
}

func (f *FunctionLookup) SetLister(ns string, lister corelister.EndpointsNamespaceLister) {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.Listers[ns] = lister
}

func getNamespace(name, defaultNamespace string) string {
	namespace := defaultNamespace
	if strings.Contains(name, ".") {
		namespace = name[strings.LastIndexAny(name, ".")+1:]
	}
	return namespace
}

func (l *FunctionLookup) Resolve(name string) (url.URL, string, error) {
    lock.Lock()
    defer lock.Unlock()
	functionName := name
	namespace := getNamespace(name, l.DefaultNamespace)
	if err := l.verifyNamespace(namespace); err != nil {
		return url.URL{}, "", err
	}

	if strings.Contains(name, ".") {
		functionName = strings.TrimSuffix(name, "."+namespace)
	}

	nsEndpointLister := l.GetLister(namespace)

	if nsEndpointLister == nil {
		l.SetLister(namespace, l.EndpointLister.Endpoints(namespace))

		nsEndpointLister = l.GetLister(namespace)
	}

	svc, err := nsEndpointLister.Get(functionName)
	if err != nil {
		return url.URL{}, "", fmt.Errorf("error listing \"%s.%s\": %s", functionName, namespace, err.Error())
	}

	if len(svc.Subsets) == 0 {
		return url.URL{}, "", fmt.Errorf("no subsets available for \"%s.%s\"", functionName, namespace)
	}

	// all := len(svc.Subsets[0].Addresses)
	if len(svc.Subsets[0].Addresses) == 0 {
		return url.URL{}, "", fmt.Errorf("no addresses in subset for \"%s.%s\"", functionName, namespace)
	}
	/*
	val, ok := l.routeMap2D[functionName]
	if ok {
		fmt.Println("Func", functionName, "'s ips ", val)
	} else {
		fmt.Println("make sub map")
		l.routeMap2D[functionName] = make(map[string]int64)
		for _, v := range svc.Subsets[0].Addresses {
			// fmt.Println("v:", v)
			_, ok := l.routeMap2D[functionName][v.IP]
			if !ok {
				l.routeMap2D[functionName][v.IP] = 0
			}
		}
	}


	for _, v := range svc.Subsets[0].Addresses {
		_, ok := l.routeMap2D[functionName][v.IP]
		if !ok {
			l.routeMap2D[functionName][v.IP] = 0
			fmt.Println("add endpoints:", v.IP)
		}
	}
	
	
	if len(l.routeMap2D[functionName]) != len(svc.Subsets[0].Addresses) {
		// fmt.Println("delete endpoints")
		goldIPs := []string{}
		for _, v := range svc.Subsets[0].Addresses {
			goldIPs = append(goldIPs, v.IP)
		}
		for key, _ := range l.routeMap2D[functionName] {
			if !containsIP(goldIPs, key) {
				delete( l.routeMap2D[functionName], key)
				fmt.Println("delete endpoints:", key)
			}
		}
	}

	if len(l.routeMap2D[functionName]) != len(svc.Subsets[0].Addresses) {
		panic(err)
	}
	*/
	// for _, v := range svc.Subsets[0].Addresses {
	// 	// fmt.Println("i", i, ", v:", v)
	// }

	// target := rand.Intn(all)

	// serviceIP := svc.Subsets[0].Addresses[target].IP
	start := time.Now()
	goldIPs := []string{}
	for _, v := range svc.Subsets[0].Addresses {
		goldIPs = append(goldIPs, v.IP)
	}
	serviceIP := selectDT(goldIPs, functionName)
	// serviceIP := max(l.routeMap2D[functionName], functionName)
	seconds := time.Since(start)
	log.Println("max() duration:", seconds.Seconds())

	if serviceIP == "" {
		provider_url := "http://127.0.0.1:8081/"
		urlPath := fmt.Sprintf("%ssystem/scale-function/%s?namespace=%s", provider_url, functionName, "openfaas-fn")
		scaleReq := ScaleServiceRequest{
			ServiceName: functionName,
			Replicas:    uint64(len(svc.Subsets[0].Addresses) + 1),
		}
		requestBody, err := json.Marshal(scaleReq)
		_, err = http.Post(urlPath, "application/json", bytes.NewBuffer(requestBody))
		if err != nil {
			panic(err)
		}
		return url.URL{}, "", fmt.Errorf("no addresses in subset for \"%s.%s\" now. Will scale.", functionName, namespace)
	}

	// l.routeMap2D[functionName][serviceIP] = time.Now().UnixNano()

	urlStr := fmt.Sprintf("http://%s:%d", serviceIP, watchdogPort)

	urlRes, err := url.Parse(urlStr)
	if err != nil {
		return url.URL{}, "", err
	}
	// branch DT
	contextString, _ := json.Marshal( GetConcurrency(serviceIP) )
	// fmt.Println("[CONTEXT INFO]", functionName, string(contextString))
	return *urlRes, string(contextString), nil
}

func (l *FunctionLookup) verifyNamespace(name string) error {
	if name != "kube-system" {
		return nil
	}
	// ToDo use global namepace parse and validation
	return fmt.Errorf("namespace not allowed")
}
